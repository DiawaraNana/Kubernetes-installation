
#!/bin/bash
# Fichier de log
LOGFILE="install_$(date +'%Y%m%d_%H%M%S').log"

# Rediriger stdout et stderr vers le fichier de log ET vers la console
exec > >(tee -a "$LOGFILE") 2>&1

echo "DÃ©but de l'installation Ã  $(date)"


# Fonction pour exÃ©cuter une commande critique avec retry
run_with_retry() {
  local cmd="$1"
  local description="$2"

  until eval "$cmd"; do
    echo "âŒ Erreur lors de : $description"
    echo "ğŸ’¡ Veuillez corriger le problÃ¨me puis appuyez sur EntrÃ©e pour rÃ©essayer, ou Ctrl+C pour quitter."
    read -r
  done
  echo "âœ… Ã‰tape rÃ©ussie : $description"
}

wait_for_disk() {
  local disk=$1
  echo "â³ Attente du disque $disk..."

  until [ -b "$disk" ]; do
    echo "Disque $disk non trouvÃ©, attente 5s..."
    sleep 5
  done

  echo "âœ… Disque $disk trouvÃ©."
}

wait_for_operator_ready() {
  echo "â³ Attente que le pod rook-ceph-operator soit en Ã©tat Running..."

  for i in {1..30}; do
    STATUS=$(kubectl -n rook-ceph get pod -l app=rook-ceph-operator -o jsonpath="{.items[0].status.phase}" 2>/dev/null || echo "")
    IMAGE_ERR=$(kubectl -n rook-ceph get pod -l app=rook-ceph-operator -o jsonpath="{.items[0].status.containerStatuses[0].state.waiting.reason}" 2>/dev/null || echo "")

    if [[ "$STATUS" == "Running" ]]; then
      echo "âœ… L'opÃ©rateur Rook Ceph est prÃªt."
      return 0
    elif [[ "$IMAGE_ERR" == "ImagePullBackOff" || "$IMAGE_ERR" == "ErrImagePull" ]]; then
      echo "âŒ Ã‰chec : impossible de rÃ©cupÃ©rer l'image du pod rook-ceph-operator."
      echo "ğŸ’¡ Astuce : vÃ©rifie que l'image est correcte dans operator.yaml"
      return 1
    else
      echo "âŒ› En attente... (Ã©tat actuel: $STATUS)"
      sleep 10
    fi
  done

  echo "âŒ Timeout : le pod rook-ceph-operator n'a pas atteint l'Ã©tat Running."
  return 1
}
wait_for_pods_ready() {
  namespace=$1
  timeout=${2:-600}  # timeout 10 minutes par dÃ©faut
  interval=10

  echo "â³ Attente que tous les pods dans le namespace '$namespace' soient en Ã©tat Ready..."

  elapsed=0
  while true; do
    # VÃ©rifier les pods qui ne sont pas Ready
    not_ready=$(kubectl get pods -n "$namespace" --no-headers | grep -v 'Running' | grep -v 'Completed' | wc -l)
    
    # Alternativement, on peut aussi vÃ©rifier le champ Ready via jsonpath
    not_ready_count=$(kubectl get pods -n "$namespace" -o jsonpath='{range .items[]}{.metadata.name}{" "}{range .status.conditions[]}{.type}{"="}{.status}{" "}{end}{"\n"}{end}' \
    | grep -v 'Ready=True' | wc -l)

    if [ "$not_ready" -eq 0 ]; then
      echo "âœ… Tous les pods sont Running et Ready."
      break
    fi

    if [ "$elapsed" -ge "$timeout" ]; then
      echo "âš ï¸ Timeout atteint, certains pods ne sont toujours pas prÃªts :"
      kubectl get pods -n "$namespace"
      exit 1
    fi

    echo "âš ï¸ Il reste $not_ready pods non prÃªts. Nouvelle vÃ©rification dans $interval secondes..."
    sleep "$interval"
    elapsed=$((elapsed + interval))
  done
}


echo "ğŸš€ Mise Ã  jour du systÃ¨me..."
run_with_retry "sudo apt update && sudo apt upgrade -y" "mise Ã  jour du systÃ¨me"

echo "ğŸ“¦ Installation des paquets nÃ©cessaires..."
run_with_retry "sudo apt install -y curl apt-transport-https ca-certificates software-properties-common gnupg git conntrack ethtool" "installation des paquets"

echo "ğŸ”‘ Ajout de la clÃ© GPG pour Docker..."
run_with_retry "curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg" "ajout clÃ© GPG Docker"

echo "ğŸ“ Ajout du dÃ©pÃ´t Docker..."
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

echo "ğŸ”„ Mise Ã  jour des paquets avec Docker..."
sudo apt update

echo "ğŸ³ Installation de Docker CE et Containerd..."
run_with_retry "sudo apt install -y docker-ce docker-ce-cli containerd.io"

echo "âš™ï¸ Configuration de Containerd..."
sudo swapoff -a
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab

run_with_retry "sudo tee /etc/modules-load.d/containerd.conf <<EOF
overlay
br_netfilter
EOF"

sudo modprobe overlay
sudo modprobe br_netfilter

sudo tee /etc/sysctl.d/kubernetes.conf <<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF

echo "ğŸ” Application de la configuration sysctl..."
sudo sysctl --system

echo "ğŸ› ï¸ GÃ©nÃ©ration du fichier de config Containerd..."
sudo mkdir -p /etc/containerd
run_with_retry "sudo containerd config default | sudo tee /etc/containerd/config.toml > /dev/null"
run_with_retry "sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml"

echo "ğŸ”„ RedÃ©marrage de Containerd..."
sudo systemctl restart containerd
sudo systemctl enable containerd

echo "ğŸ”‘ Ajout du dÃ©pÃ´t Kubernetes..."
sudo mkdir -p /etc/apt/keyrings
run_with_retry "curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg"
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list

echo "ğŸ”„ Mise Ã  jour des paquets..."
sudo apt update

echo "ğŸ“¥ Installation de kubelet, kubeadm, kubectl..."
run_with_retry "sudo apt install -y kubelet kubeadm kubectl"
sudo apt-mark hold kubelet kubeadm kubectl


echo "ğŸš§ Initialisation du cluster Kubernetes..."
run_with_retry "sudo kubeadm init --pod-network-cidr=192.168.0.0/16 || { echo 'âŒ Ã‰chec de l''initialisation de kubeadm.'; exit 1; }"

echo "ğŸ” Configuration de l'accÃ¨s kubectl pour l'utilisateur actuel..."
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

echo "ğŸŒ DÃ©ploiement du rÃ©seau Calico (CNI)..."
run_with_retry "kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml || { echo 'âŒ Ã‰chec du dÃ©ploiement de Calico.'; exit 1; }"

echo "âš ï¸ Suppression du taint sur le nÅ“ud master pour y permettre l'exÃ©cution de pods..."
run_with_retry "kubectl taint nodes --all node-role.kubernetes.io/control-plane- 2>/dev/null || true"



echo "ğŸ”‘ CrÃ©ation d'un token d'accÃ¨s pour rejoindre des nÅ“uds workers..."
JOIN_COMMAND=$(kubeadm token create --print-join-command)
echo "ğŸ’¡ Pour ajouter des nÅ“uds workers, exÃ©cutez cette commande sur le worker :"
echo "$JOIN_COMMAND"


echo "ğŸ“¦ DÃ©ploiement de Rook Ceph..."
run_with_retry "git clone https://github.com/rook/rook.git" "clonage du repo rook"

cd rook/deploy/examples || { echo "âŒ Impossible de changer de rÃ©pertoire rook/deploy/examples"; exit 1; }

wait_for_disk "/dev/sdb"

run_with_retry "kubectl apply -f crds.yaml -f common.yaml -f operator.yaml" "application CRDs et operator Rook Ceph"

echo "â³ Attente du dÃ©ploiement de l'opÃ©rateur Rook Ceph..."
until wait_for_operator_ready; do
  echo "â³ Tentative de redÃ©ploiement operator..."
  run_with_retry "kubectl apply -f operator.yaml" "redÃ©ploiement operator rook-ceph"
done

echo "â³ Attente du dÃ©ploiement de l'opÃ©rateur Rook Ceph..."
wait_for_operator_ready || exit 1

kubectl -n rook-ceph rollout status deployment/rook-ceph-operator --timeout=120s

echo "â³ Attente du namespace rook-ceph..."
until kubectl get namespace rook-ceph; do
  echo "Attente du namespace rook-ceph..."
  sleep 3
done

echo "â³ VÃ©rification de la prÃ©sence du CRD CephCluster..."
until kubectl get crd cephclusters.ceph.rook.io; do
  echo "Attente du CRD CephCluster..."
  sleep 5
done

echo "ğŸ“¦ CrÃ©ation du cluster Ceph..."
kubectl apply -f cluster.yaml

echo "â³ Attente des pods Ceph prÃªts..."
#kubectl -n rook-ceph wait --for=condition=Ready pod --all --timeout=400s
echo "â³ Attente que tous les pods rook-ceph soient prÃªts..."

while true; do
  not_ready=$(kubectl -n rook-ceph get pods --no-headers | grep -v "Running\|Completed" | wc -l)
  if [ "$not_ready" -eq 0 ]; then
    echo "âœ… Tous les pods sont prÃªts !"
    break
  fi
  echo "â³ Certains pods ne sont pas prÃªts, attente de 5 secondes..."
  sleep 5
done


echo "ğŸ“ CrÃ©ation du filesystem Ceph..."
kubectl apply -f filesystem.yaml

echo "ğŸ“¦ CrÃ©ation du StorageClass CephFS..."
kubectl -n rook-ceph apply -f csi/cephfs/storageclass.yaml

echo "ğŸ”§ Passage du StorageClass 'rook-ceph-block' en dÃ©faut..."
#kubectl patch sc rook-ceph-block -p '{"metadata":{"storageclass.kubernetes.io/is-default-class":"true"}}'
echo "ğŸ“¦ CrÃ©ation du StorageClass rook-ceph-block..."

cat <<EOF | kubectl apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-block
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
  clusterID: rook-ceph
  pool: replicapool
  imageFeatures: layering
  csi.storage.k8s.io/fstype: xfs
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer
EOF

kubectl patch storageclass rook-ceph-block -p '{"metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'


# Par exemple pour Kubeflow:
cd ../../.. || exit 1
echo "ğŸ“¦ DÃ©ploiement de Kubeflow..."

run_with_retry "git clone https://github.com/kubeflow/manifests.git" "clonage Kubeflow manifests"
cd manifests || exit 1

# Installer kustomize si besoin
if ! command -v kustomize &> /dev/null; then
  echo "âš™ï¸ Installation de kustomize..."
  if command -v snap &> /dev/null; then
    run_with_retry "sudo snap install kustomize" "installation de kustomize via snap"
  else
    echo "âš ï¸ Snap non disponible, utilisation de kubectl kustomize"
    alias kustomize="kubectl kustomize"
  fi
fi

# VÃ©rifier que yq est disponible
if ! command -v yq &> /dev/null; then
  echo "âš™ï¸ Installation de yq..."
  if command -v snap &> /dev/null; then
    run_with_retry "sudo snap install yq" "installation de yq via snap"
  elif command -v brew &> /dev/null; then
    run_with_retry "brew install yq" "installation de yq via brew"
  else
    echo "âŒ Impossible d'installer yq automatiquement. Veuillez l'installer manuellement."
    exit 1
  fi
fi

# Appliquer les manifests sans annotation trop volumineuse
#run_with_retry "kustomize build example | yq 'del(.metadata.annotations)' | kubectl apply -f -" "application manifests Kubeflow sans annotations"



kustomize build common/kubeflow-namespace/base | yq 'del(.metadata.annotations)' | kubectl apply -f -


wait_for_pods "kubeflow"
echo "âœ… Installation complÃ¨te terminÃ©e !"

# Port forward (non bloquant)
kubectl -n istio-system port-forward svc/istio-ingressgateway 8080:80 &